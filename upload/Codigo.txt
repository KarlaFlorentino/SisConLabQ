#include "opencv2/core.hpp"
#include "opencv2/imgproc.hpp"
#include "opencv2/imgcodecs.hpp"
#include "opencv2/highgui.hpp"

#include <math.h>
#include <iostream>

using namespace cv;
using namespace std;

Mat thresh;
String endImagem;
int minArea, maxArea;
float areaQuadrado, areaEsperada,largEsperada,compEsperado;


static double angle( Point pt1, Point pt2, Point pt0 ){
    double dx1 = pt1.x - pt0.x;
    double dy1 = pt1.y - pt0.y;
    double dx2 = pt2.x - pt0.x;
    double dy2 = pt2.y - pt0.y;
    return (dx1*dx2 + dy1*dy2)/sqrt((dx1*dx1 + dy1*dy1)*(dx2*dx2 + dy2*dy2) + 1e-10);
}

static void findObjects( const Mat& image, vector<vector<Point> >& square, vector<vector<Point> >& leafs){
    Mat pyr, timg, gray0(image.size(), CV_8U), gray;
    vector<vector<Point> > contours;

    cvtColor( image, gray, COLOR_BGR2GRAY );

    threshold( gray, thresh, 0, 255, THRESH_BINARY_INV|THRESH_OTSU);

    findContours(thresh, contours, RETR_LIST, CHAIN_APPROX_SIMPLE);

    vector<Point> approx;

    for(size_t i = 0; i < contours.size(); i++){
        approxPolyDP(contours[i], approx, arcLength(contours[i], true)*0.02, true);

        if(approx.size() == 4 && fabs(contourArea(approx)) > 1000 && isContourConvex(approx) ){
            double maxCosine = 0;

            for( int j = 2; j < 5; j++ ){
                double cosine = fabs(angle(approx[j%4], approx[j-2], approx[j-1]));
                maxCosine = MAX(maxCosine, cosine);
             }

             if( maxCosine < 0.3 )
                square.push_back(contours[i]);
        }else if(fabs(contourArea(approx)) > minArea && fabs(contourArea(approx)) < maxArea){
            leafs.push_back(contours[i]);
        }
    }
}

static void area(const Mat& image, vector<vector<Point> >& square,vector<vector<Point> >& leafs){
    float largSquare,compSquare;

    //-------------------SQUARE----------------------

    RotatedRect minSquare = minAreaRect( Mat(square[0]) );
    Point2f rect_points[4];
    minSquare.points( rect_points );

    largSquare = sqrt((pow((rect_points[1].x - rect_points[0].x),2)+pow((rect_points[1].y - rect_points[0].y),2)));
    compSquare = sqrt((pow((rect_points[0].x - rect_points[3].x),2)+pow((rect_points[0].y - rect_points[3].y),2)));

    /*line( image, rect_points[0], rect_points[3], Scalar(255,0,255),2);
    line( image, rect_points[3], rect_points[2], Scalar(0,255,255),2);
    line( image, rect_points[2], rect_points[1], Scalar(255,0,255),2);
    line( image, rect_points[1], rect_points[0], Scalar(0,255,255),2);*/


    //---------------------LEAFS-----------------------

    for( int i = 0; i < leafs.size(); i++ ){
        RotatedRect minLeafs = minAreaRect( Mat(leafs[i]) );

        Point2f rect_points[4];
        minLeafs.points( rect_points );

        float aux = sqrt((pow((rect_points[1].x - rect_points[0].x),2)+pow((rect_points[1].y - rect_points[0].y),2)));
        aux = (aux * sqrt(float(areaQuadrado)))/largSquare;

        float aux2 = sqrt((pow((rect_points[0].x - rect_points[3].x),2)+pow((rect_points[0].y - rect_points[3].y),2)));
        aux2 = (aux2 * sqrt(float(areaQuadrado)))/compSquare;

        cout<<"Imagem: "<<endImagem;
        if(aux2 > aux){
            cout<<"\nLargura: "<<aux<<" "<<abs(largEsperada - aux)<<" "<<(abs(largEsperada - aux)/largEsperada) * 100<<" "<<largEsperada;
            cout<<"\nComprimento: "<<aux2<<" "<<abs(compEsperado - aux2)<<" "<<(abs(compEsperado - aux2)/compEsperado) * 100<<" "<<compEsperado<<"\n\n";
        }else{
            cout<<"\nLargura: "<<aux2<<" "<<abs(largEsperada - aux2)<<" "<<(abs(largEsperada - aux2)/largEsperada) * 100<<" "<<largEsperada;
            cout<<"\nComprimento: "<<aux<<" "<<abs(compEsperado - aux)<<" "<<(abs(compEsperado - aux)/compEsperado) * 100<<" "<<compEsperado<<"\n\n";
        }

        /*line( image, rect_points[0], rect_points[3], Scalar(255,0,255),2);
        line( image, rect_points[3], rect_points[2], Scalar(0,255,255),2);
        line( image, rect_points[2], rect_points[1], Scalar(255,0,255),2);
        line( image, rect_points[1], rect_points[0], Scalar(0,255,255),2);*/

        }
    /*
    namedWindow( "Display window",  WINDOW_NORMAL); // Create a window for display.
    imshow( "Display window", image);

    //imwrite();

    vector<double> area(leafs.size());
    int cont;
    cont = contourArea(square[0]);

    cout<<"Imagem: "<<endImagem;

    for( size_t i = 0; i< leafs.size(); i++ ){        
        cout<<"\nArea: "<<(contourArea(leafs[i]) * areaQuadrado)/cont;
        //area[i]=(contourArea(leafs[i]) * areaQuadrado)/cont;
     }

    cout<<"\n\n";

    /*for( size_t i = 0; i< leafs.size(); i++ ){
        cout<<endImagem<<" "<<area[i]<<" "<<abs(areaEsperada - area[i])<<" "<<(abs(areaEsperada - area[i])/areaEsperada) * 100<<" "<<areaEsperada<<"\n";
     }*/
}

static void drawSquares( Mat& image, const vector<vector<Point> >& squares,const vector<vector<Point> >& others){
    for( size_t i = 0; i < squares.size(); i++ ){
        const Point* p = &squares[i][0];
        int n = (int)squares[i].size();
        polylines(image, &p, &n, 1, true, Scalar(0,255,0), 20, LINE_AA);
    }
    for( size_t i = 0; i < others.size(); i++ ){
        const Point* p = &others[i][0];
        int n = (int)others[i].size();
        polylines(image, &p, &n, 1, true, Scalar(255,0,0), 20, LINE_AA);
    }

    namedWindow("Window", WINDOW_NORMAL);

    imshow("Window",image);
}


const String keys = "{endImagem     |  |}"
                    "{areaQuadrado  |  | }"
                    "{areaEsperada  |  | }"
                    "{largEsperada  |  | }"
                    "{compEsperado  |  | }"
                    "{minArea       |  | }"
                    "{maxArea       |  | }";

int main(int argc, char** argv){
    CommandLineParser parser(argc, argv, keys);

    endImagem = parser.get<String>("endImagem");
    areaQuadrado = parser.get<float>("areaQuadrado");
    //areaEsperada = parser.get<float>("areaEsperada");
    largEsperada = parser.get<float>("largEsperada");
    compEsperado = parser.get<float>("compEsperado");
    minArea = parser.get<int>("minArea");
    maxArea = parser.get<int>("maxArea");

    Mat image;
    vector<vector<Point> > square;
    vector<vector<Point> > leafs;

    image = imread( endImagem, IMREAD_COLOR );

    if( image.empty() ){
        cout <<  "Could not open or find the image" << std::endl ;
        return -1;
    }

    findObjects(image, square, leafs);
    area(image,square, leafs);
    drawSquares(image,square,leafs);

    waitKey(0);
    return 0;

    }
